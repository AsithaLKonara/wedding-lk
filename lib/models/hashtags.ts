import mongoose, { Schema, Document } from 'mongoose';

export interface IHashtag extends Document {
  // Hashtag Information
  tag: string; // The hashtag text (without #)
  
  // Usage Statistics
  usage: {
    totalUses: number;
    totalPosts: number;
    totalStories: number;
    totalReels: number;
    totalShares: number;
    uniqueUsers: number;
  };
  
  // Trending Information
  trending: {
    isTrending: boolean;
    trendingScore: number; // 0-100
    trendingRank?: number;
    trendingPeriod: 'hourly' | 'daily' | 'weekly' | 'monthly';
    peakUsage?: Date;
    peakUsageCount?: number;
  };
  
  // Category Information
  category: {
    primary: string; // Main category (wedding, vendor, venue, etc.)
    secondary?: string[]; // Sub-categories
    autoGenerated: boolean; // Whether category was auto-detected
  };
  
  // Content Analysis
  contentAnalysis: {
    sentiment: 'positive' | 'neutral' | 'negative';
    sentimentScore: number; // -1 to 1
    topics: string[]; // Extracted topics
    languages: string[]; // Languages detected in content
    locations: Array<{
      city: string;
      state: string;
      count: number;
    }>;
  };
  
  // Engagement Metrics
  engagement: {
    averageLikes: number;
    averageComments: number;
    averageShares: number;
    engagementRate: number; // Percentage
    reach: number; // Estimated reach
    impressions: number; // Estimated impressions
  };
  
  // Time-based Analytics
  analytics: {
    hourlyUsage: Array<{
      hour: number; // 0-23
      count: number;
    }>;
    dailyUsage: Array<{
      date: Date;
      count: number;
    }>;
    weeklyUsage: Array<{
      week: number; // Week of year
      count: number;
    }>;
    monthlyUsage: Array<{
      month: number; // 1-12
      count: number;
    }>;
  };
  
  // Related Hashtags
  relatedTags: Array<{
    tag: string;
    correlationScore: number; // 0-1
    coOccurrenceCount: number;
  }>;
  
  // Moderation
  moderation: {
    isApproved: boolean;
    isBlocked: boolean;
    moderationReason?: string;
    moderatedBy?: mongoose.Types.ObjectId;
    moderatedAt?: Date;
    reportedCount: number;
    lastReported?: Date;
  };
  
  // SEO Information
  seo: {
    metaDescription?: string;
    keywords: string[];
    slug: string;
    canonicalUrl?: string;
  };
  
  // Status
  status: 'active' | 'pending' | 'blocked' | 'archived';
  
  // Timestamps
  createdAt: Date;
  updatedAt: Date;
  lastUsed?: Date;
}

const HashtagSchema = new Schema<IHashtag>({
  tag: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true,
    maxlength: 100
  },
  
  usage: {
    totalUses: { type: Number, default: 0 },
    totalPosts: { type: Number, default: 0 },
    totalStories: { type: Number, default: 0 },
    totalReels: { type: Number, default: 0 },
    totalShares: { type: Number, default: 0 },
    uniqueUsers: { type: Number, default: 0 }
  },
  
  trending: {
    isTrending: { type: Boolean, default: false },
    trendingScore: { type: Number, default: 0, min: 0, max: 100 },
    trendingRank: Number,
    trendingPeriod: {
      type: String,
      enum: ['hourly', 'daily', 'weekly', 'monthly'],
      default: 'daily'
    },
    peakUsage: Date,
    peakUsageCount: Number
  },
  
  category: {
    primary: { type: String, required: true },
    secondary: [String],
    autoGenerated: { type: Boolean, default: true }
  },
  
  contentAnalysis: {
    sentiment: {
      type: String,
      enum: ['positive', 'neutral', 'negative'],
      default: 'neutral'
    },
    sentimentScore: { type: Number, default: 0, min: -1, max: 1 },
    topics: [String],
    languages: [String],
    locations: [{
      city: String,
      state: String,
      count: { type: Number, default: 0 }
    }]
  },
  
  engagement: {
    averageLikes: { type: Number, default: 0 },
    averageComments: { type: Number, default: 0 },
    averageShares: { type: Number, default: 0 },
    engagementRate: { type: Number, default: 0 },
    reach: { type: Number, default: 0 },
    impressions: { type: Number, default: 0 }
  },
  
  analytics: {
    hourlyUsage: [{
      hour: { type: Number, min: 0, max: 23 },
      count: { type: Number, default: 0 }
    }],
    dailyUsage: [{
      date: Date,
      count: { type: Number, default: 0 }
    }],
    weeklyUsage: [{
      week: { type: Number, min: 1, max: 52 },
      count: { type: Number, default: 0 }
    }],
    monthlyUsage: [{
      month: { type: Number, min: 1, max: 12 },
      count: { type: Number, default: 0 }
    }]
  },
  
  relatedTags: [{
    tag: { type: String, required: true },
    correlationScore: { type: Number, min: 0, max: 1 },
    coOccurrenceCount: { type: Number, default: 0 }
  }],
  
  moderation: {
    isApproved: { type: Boolean, default: true },
    isBlocked: { type: Boolean, default: false },
    moderationReason: String,
    moderatedBy: { type: Schema.Types.ObjectId, ref: 'User' },
    moderatedAt: Date,
    reportedCount: { type: Number, default: 0 },
    lastReported: Date
  },
  
  seo: {
    metaDescription: String,
    keywords: [String],
    slug: { type: String, unique: true, sparse: true },
    canonicalUrl: String
  },
  
  status: {
    type: String,
    enum: ['active', 'pending', 'blocked', 'archived'],
    default: 'active'
  },
  
  lastUsed: Date
}, {
  timestamps: true
});

// Indexes
HashtagSchema.index({ tag: 1 });
HashtagSchema.index({ 'usage.totalUses': -1 });
HashtagSchema.index({ 'trending.isTrending': 1 });
HashtagSchema.index({ 'trending.trendingScore': -1 });
HashtagSchema.index({ 'trending.trendingRank': 1 });
HashtagSchema.index({ 'category.primary': 1 });
HashtagSchema.index({ 'category.secondary': 1 });
HashtagSchema.index({ 'contentAnalysis.sentiment': 1 });
HashtagSchema.index({ 'engagement.engagementRate': -1 });
HashtagSchema.index({ status: 1 });
HashtagSchema.index({ lastUsed: -1 });
HashtagSchema.index({ createdAt: -1 });

// Text search index
HashtagSchema.index({
  tag: 'text',
  'category.primary': 'text',
  'category.secondary': 'text',
  'contentAnalysis.topics': 'text',
  'seo.keywords': 'text'
});

// Compound indexes
HashtagSchema.index({ 'category.primary': 1, 'usage.totalUses': -1 });
HashtagSchema.index({ 'trending.isTrending': 1, 'trending.trendingScore': -1 });
HashtagSchema.index({ status: 1, 'usage.totalUses': -1 });

// Instance methods
HashtagSchema.methods.incrementUsage = function(contentType: string, userId: string) {
  this.usage.totalUses += 1;
  this.lastUsed = new Date();
  
  switch (contentType) {
    case 'post':
      this.usage.totalPosts += 1;
      break;
    case 'story':
      this.usage.totalStories += 1;
      break;
    case 'reel':
      this.usage.totalReels += 1;
      break;
    case 'share':
      this.usage.totalShares += 1;
      break;
  }
  
  // Update unique users count (this would need to be tracked separately in a real implementation)
  // For now, we'll just increment it
  this.usage.uniqueUsers += 1;
  
  return this.save();
};

HashtagSchema.methods.updateTrendingScore = function() {
  // Calculate trending score based on recent usage
  const now = new Date();
  const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
  
  // This is a simplified calculation - in reality, you'd analyze recent usage patterns
  const recentUsage = this.usage.totalUses; // This should be filtered by recent time
  
  // Calculate trending score (0-100)
  this.trending.trendingScore = Math.min(100, (recentUsage / 100) * 100);
  
  // Determine if trending
  this.trending.isTrending = this.trending.trendingScore > 50;
  
  return this.save();
};

HashtagSchema.methods.addRelatedTag = function(relatedTag: string, correlationScore: number, coOccurrenceCount: number) {
  const existing = this.relatedTags.find(rt => rt.tag === relatedTag);
  
  if (existing) {
    existing.correlationScore = correlationScore;
    existing.coOccurrenceCount = coOccurrenceCount;
  } else {
    this.relatedTags.push({
      tag: relatedTag,
      correlationScore,
      coOccurrenceCount
    });
  }
  
  // Sort by correlation score
  this.relatedTags.sort((a, b) => b.correlationScore - a.correlationScore);
  
  // Keep only top 20 related tags
  this.relatedTags = this.relatedTags.slice(0, 20);
  
  return this.save();
};

HashtagSchema.methods.updateAnalytics = function(hour: number, date: Date) {
  // Update hourly usage
  let hourlyData = this.analytics.hourlyUsage.find(h => h.hour === hour);
  if (!hourlyData) {
    hourlyData = { hour, count: 0 };
    this.analytics.hourlyUsage.push(hourlyData);
  }
  hourlyData.count += 1;
  
  // Update daily usage
  const dayKey = date.toISOString().split('T')[0];
  let dailyData = this.analytics.dailyUsage.find(d => 
    d.date.toISOString().split('T')[0] === dayKey
  );
  if (!dailyData) {
    dailyData = { date: new Date(dayKey), count: 0 };
    this.analytics.dailyUsage.push(dailyData);
  }
  dailyData.count += 1;
  
  // Update weekly usage
  const weekNumber = this.getWeekNumber(date);
  let weeklyData = this.analytics.weeklyUsage.find(w => w.week === weekNumber);
  if (!weeklyData) {
    weeklyData = { week: weekNumber, count: 0 };
    this.analytics.weeklyUsage.push(weeklyData);
  }
  weeklyData.count += 1;
  
  // Update monthly usage
  const month = date.getMonth() + 1;
  let monthlyData = this.analytics.monthlyUsage.find(m => m.month === month);
  if (!monthlyData) {
    monthlyData = { month, count: 0 };
    this.analytics.monthlyUsage.push(monthlyData);
  }
  monthlyData.count += 1;
  
  return this.save();
};

HashtagSchema.methods.getWeekNumber = function(date: Date) {
  const firstDayOfYear = new Date(date.getFullYear(), 0, 1);
  const pastDaysOfYear = (date.getTime() - firstDayOfYear.getTime()) / 86400000;
  return Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);
};

HashtagSchema.methods.block = function(reason: string, moderatedBy: string) {
  this.status = 'blocked';
  this.moderation.isBlocked = true;
  this.moderation.moderationReason = reason;
  this.moderation.moderatedBy = moderatedBy;
  this.moderation.moderatedAt = new Date();
  return this.save();
};

HashtagSchema.methods.unblock = function() {
  this.status = 'active';
  this.moderation.isBlocked = false;
  this.moderation.moderationReason = undefined;
  this.moderation.moderatedBy = undefined;
  this.moderation.moderatedAt = undefined;
  return this.save();
};

HashtagSchema.methods.report = function() {
  this.moderation.reportedCount += 1;
  this.moderation.lastReported = new Date();
  return this.save();
};

// Static methods
HashtagSchema.statics.getTrendingHashtags = function(limit: number = 20) {
  return this.find({
    'trending.isTrending': true,
    status: 'active'
  }).sort({ 'trending.trendingScore': -1 }).limit(limit);
};

HashtagSchema.statics.getPopularHashtags = function(limit: number = 20) {
  return this.find({
    status: 'active'
  }).sort({ 'usage.totalUses': -1 }).limit(limit);
};

HashtagSchema.statics.getHashtagsByCategory = function(category: string, limit: number = 20) {
  return this.find({
    'category.primary': category,
    status: 'active'
  }).sort({ 'usage.totalUses': -1 }).limit(limit);
};

HashtagSchema.statics.searchHashtags = function(searchTerm: string, limit: number = 20) {
  return this.find({
    $text: { $search: searchTerm },
    status: 'active'
  }).sort({ score: { $meta: 'textScore' } }).limit(limit);
};

HashtagSchema.statics.getRelatedHashtags = function(tag: string, limit: number = 10) {
  return this.findOne({ tag }).then(hashtag => {
    if (!hashtag) return [];
    return hashtag.relatedTags.slice(0, limit);
  });
};

HashtagSchema.statics.createOrUpdateHashtag = async function(tag: string, contentType: string, userId: string) {
  const hashtag = await this.findOne({ tag });
  
  if (hashtag) {
    await hashtag.incrementUsage(contentType, userId);
    return hashtag;
  } else {
    const newHashtag = new this({
      tag,
      category: {
        primary: 'general',
        autoGenerated: true
      }
    });
    
    await newHashtag.incrementUsage(contentType, userId);
    return newHashtag;
  }
};

export const Hashtag = mongoose.models.Hashtag || mongoose.model('Hashtag', HashtagSchema);
